		// get the viewPort start point for the current layer

		// for each row in the viewPort
		// get the row from the layer
		// for each tile in the row
		// draw the tile

		// for y := 0; y < g.viewPort.height; y++ {
		// 	viewPortStart := ((g.viewPort.xy.Y + y) * 100) + g.viewPort.xy.X
		// 	viewPortEnd := viewPortStart + g.viewPort.width

		// 	t := l[viewPortStart:viewPortEnd]
		// 	i := 0
		// 	for x := viewPortStart; x < viewPortEnd; x++ {
		// 		op := &ebiten.DrawImageOptions{}
		// 		op.GeoM.Translate(float64((i%xCount)*tileSize), float64((i/xCount)*tileSize))
		// 		i := g.layers[0][x]
		// 		sx := (t % tileXCount) * tileSize
		// 		sy := (t / tileXCount) * tileSize
		// 		screen.DrawImage(tilesImage.SubImage(image.Rect(sx, sy, sx+tileSize, sy+tileSize)).(*ebiten.Image), op)
		// 		i++
		// 	}
		// }
	}

	// for _, l := range g.layers {
	// 	for i, t := range l {
	// 		op := &ebiten.DrawImageOptions{}
	// 		op.GeoM.Translate(float64((i%xCount)*tileSize), float64((i/xCount)*tileSize))

	// 		sx := (t % tileXCount) * tileSize
	// 		sy := (t / tileXCount) * tileSize
	// 		screen.DrawImage(tilesImage.SubImage(image.Rect(sx, sy, sx+tileSize, sy+tileSize)).(*ebiten.Image), op)
	// 	}
	// }

	// for _, l := range g.layers {
	// 	for i, t := range l {
	// 		op := &ebiten.DrawImageOptions{}
	// 		op.GeoM.Translate(float64((i%xCount)*tileSize), float64((i/xCount)*tileSize))

	// 		sx := (t % tileXCount) * tileSize
	// 		sy := (t / tileXCount) * tileSize
	// 		screen.DrawImage(tilesImage.SubImage(image.Rect(sx, sy, sx+tileSize, sy+tileSize)).(*ebiten.Image), op)
	// 	}
	// }

	//ebitenutil.DebugPrint(screen, fmt.Sprintf("TPS: %0.2f", ebiten.ActualTPS()))
	//ebitenutil.DebugPrint(screen, fmt.Sprintf("Keys: %v", g.keys))

	//location := ((g.playLocation.Y * 22) - 1) + g.playLocation.X

	//ebitenutil.DebugPrint(screen, fmt.Sprintf("Player location: %v", g.playLocation))